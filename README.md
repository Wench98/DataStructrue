# DataStructure
    By Wench Guo
    
    It's just a practise for the data structure and algorithm. 
    这是一个学习数据结构以及算法的项目。
    学习来源：https://www.bilibili.com/video/BV1E4411H73v/?p=1
    
## 第一部分——队列与链表
    
### Question for Sparse Array
    
    2020-04-10
    Store the sparse array into a file and read from the file to restore the original array.
    稀疏数组练习的第一遍敲完
    
### ArrayQueueDemo
    
    2020-04-11
    There is a problem in the process of running the program.
    This queue can only be used once, and the data in the queue cannot be reused.
    使用了一个一位数组来模拟一个简单的队列。但是，该数组只能被使用一次，无法做到重用。

### CircleArrayQueueDemo
    
    2020-04-12
    The key to the circular array is: modulo.
    用了一个环形数组来模拟队列，达到了队列的重用。
    
### 完善毕设、论文降重
    
    2020-04-13～2020-05-11
    完善了毕设的评论、通知以及后台管理的功能，论文重复率降到10%以下后，笔者便着手找工作。
    很惭愧，基本上没有收到简历的回应。7号投了一个简历后，过了两轮测试，约13号公司现场进行机试。
    但至今没有收到确认邮件或其他通知消息，在前两次测试中深知自己基础不够扎实。
    便开始重新回顾Java语言知识，开始学习JVM的相关知识，同时对数据结构以及算法的进行程序化实现。
    
### 单链表的创建与遍历
    
    2020-05-11
    代码实现单链表的创建以及对该单链表进行遍历，该方式是直接添加到此单链表的尾部
    文件所在包：cn.wench.linkedlist
    类名称：SingleLinkedListDemo
    
### 按顺序插入节点到单链表、修改单链表的某个节点信息
    
    2020-05-12
    在cn.wench.linkedlist.SingleLinkedListDemo.java文件中添加了addByOrder方法，实现了按照编号的顺序进行插入节点。
    在cn.wench.linkedlist.SingleLinkedListDemo.java文件中添加了update方法，实现了按照编号修改某个节点信息，但不可修改编号属性。
    
### 单链表中的节点删除
    
    2020-05-12
    在cn.wench.linkedlist.SingleLinkedListDemo.java文件中添加了delete方法，实现了对单链表中某个节点的删除——根据节点no编号。
    
### 单链表练习题
    
    2020-05-13
    1、求单链表中有效节点的个数
    解答：cn.wench.linkedlist.SingleLinkedListDemo.java文件中的getLength(HeroNode head)方法。
    2、查找单链表中的倒数第K个节点
    解答：cn.wench.linkedlist.SingleLinkedListDemo.java文件中的findLastIndexNode(HeroNode hero, int index)方法。
    
    今天面试了两家公司，一家外包，一家因为自己知识储备量不够没能抓住机会，没有怨言。
    我也不知道自己能不能找到合心意的Java开发工作，就目前来看，应该是没有任何希望了。
    我选择把Java基础打牢一点，再回头看一遍，也继续每天更新数据结构的提交，宋红康的JVM教程第一篇也已经看完大半了。
    如果这些都做完了，还是没法找到合适工作的话，那便试试看其他的出路吧。
    
    3、单链表的反转
    解答：cn.wench.linkedlist.SingleLinkedListDemo.java文件中的reverseList(HeroNode head)方法
    4、从尾到头打印单链表，使用栈的先进后出特点进行打印
    解答：cn.wench.linkedlist.SingleLinkedListDemo.java文件中的reversePrint(HeroNode hero)方法
    
    5、合并两个有序的单链表，合并之后的链表依然有序
    解答：待完成。
    
### 双向链表的增删改查
    
    2020-05-14
    cn.wench.linkedlist.DoubleLinkedListDemo.java文件实现了对双向链表的增删改查操作
    待完成：双向链表的第二种添加方式，按照编号顺序进行添加。按照单链表的顺序添加，稍作修改。
    
### 约瑟夫问题——环形链表
    
    2020-05-15
    cn.wench.linkedlist.Josephu.java文件完成了环形链表，即约瑟夫环的实现。
    数到规定数字的人出圈，直到剩下最后一个。
    
## 第二部分——栈

### 数组模拟栈
    
    2020-05-16
    cn.wench.stack 包下的ArrayStackDemo.java 文件实现了数组模拟栈的操作，编写了出栈、入栈、显示栈数据、栈空、栈满的方法。
    小练习：实现使用链表来模拟栈——cn.wench.stack 包下的LinkedListStackDemo.java文件实现了与上述一致的栈操作，使用的是单链表实现的。
    
### 栈实现综合计算器——中缀表达式
    
    2020-05-17
    示例文件：stack包下的Calculator.java——中缀表达式
    
    如何处理多位数的问题？
    解决：示例文件stack包下的Calculator.java的48～66行
    
    给表达式加入小括号——待解决
    
### 逆波兰计算器

    2020-05-18
    示例文件：stack包下的PolandNotation文件
    给出一个后缀表达式的字符串，根据字符串求出表达式的结果。
    
### 中缀转后缀表达式

    2020-05-18
    示例文件：stack包下的PolandNotation文件
    
    完整版的逆波兰计算器：支持+ - * / ()；多位数，支持小数；兼容处理，过滤任何空白字符，包括空格、制表符、换页符
    仍然使用中缀表达式转后缀表达式
    示例文件：stack包下的PerfectPolishMultiCalc文件
    
## 第三部分——递归
    
    2020-05-19
    递归的概念：
        简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂的问题，同时可以让代码便得简洁。
    
    递归调用机制的两个小案例：
        示例文件：recursion包下的RecursionTest文件
        1、打印数字
        2、打印阶乘结果
        
    递归调用规则：
        1、当程序执行到一个方法时，就会开辟一个独立的空间（栈）
        2、每个空间的数据（局部变量），是独立的
        3、如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据
        4、递归必须向退出递归的条件逼近，否则就会无限递归，出现StackOverflowError
        5、当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕
        
### 递归——迷宫问题
    
    2020-05-19
    示例文件：recursion包下的Maze文件
    setWay(int[][] map, int i, int j) —— 策略：下 -> 右 -> 上 -> 左
    setWay2(int[][] map, int i, int j) —— 策略：上 -> 右 -> 下 -> 左
    如何得出最短路径？—— 待解决，使用数组记录走通路径2的总和，总和小的即为最短路径
  
### 递归回溯——八皇后问题  
    2020-05-20
    示例文件：recursion包下的Queue8文件
    核心思路：在皇后在第一行时，找出所有可能的情况；第一行所有可能找尽后，找出皇后在第二行时所有可能的情况。
    
## 第四部分——排序算法

    2020-05-21
    排序算法的介绍——排序是将一组数据，依照指定的顺序进行排列的过程
    排序的分类：
        1、内部排序：值将需要处理的所有数据都加载到内部存储器中进行排序。
            包括：直接插入排序、希尔排序、简单选择排序、堆排序、冒泡排序、快速排序、归并排序、基数排序
        2、外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。
    T(n)：随着n规模的不断增加，常数项可以忽略、低次项可以忽略、高次项系数可以忽略
    
    常数阶O(1) < 对数阶O(log2 n) < 线性阶O(n) < 线性对数阶O(nlog2 n) < 平方阶O(n^2) < 立方阶O(n^3) < k次方阶O(n^k) < 指数阶O(2^n)
    
### 冒泡排序

    2020-05-21
    实现文件：sort包下的BubbleSort文件——说明注释肯定不能少
    
### 选择排序

    2020-05-22
    实现文件：sort包下的SelectSort文件——详尽的注释与说明会使更容易理解
    
### 插入排序

    2020-05-23
    
    今天答辩结束了，过程不好也不差吧。
    答辩组长老师认为我对自己的毕设框架很熟悉，问了一些基本的问题，也有些我未知的东西。
    往上翻看了一下，我已经连续10多天跟着这个视频走了吧。
    看着视频分析完，理解完后，跟着敲一遍，基本上能明白为什么会这样处理。
    但同时也明白了自己其实也并不是什么聪明人吧，看完一遍基本上能够明白，却仍然无法自行创造出来。
    目前仍在找工作，学历也许是一方面的原因，没有任何开发的实习经验兴许也是一方面的原因，求职很难。
    看到这里的你啊，别灰心，坚持下去。
    跟着我的时间轴走完这一套数据结构与算法，慢慢走下去，但请不要停下来。
    谢谢你能看完这些。
    
    插入排序的基本思想：
    把n个待排序的元素看成一个有序表和一个无序表
    开始时有序表中只包含一个元素，无序表中包含有（n-1）元素
    排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较
    将它插入到有序表中的适当位置，使之成为新的有序表
    
    实现文件：sort包下的InsertSort文件
    
### 希尔排序

    2020-05-24～2020-05-25
    24号学校毕业答辩结束，答辩成绩为35，最终成绩83。
    25号写党员转正申请书，写完了一支笔的笔油，手指写得也酸痛。
    这两天算是彻底颓废了。
    
    2020-05-26
    希尔排序基本思想：
    希尔排序是把记录按下标的一定增量进行分组，对每组使用直接插入排序算法排序；
    随着增量逐渐减少，每组包含的关键词越来越少，当增量减至1时，整个文件恰被分成一组，算法便终止
    
    代码实现文件：sort包下的ShellSort文件
    
### 快速排序

    2020-05-26
    快速排序法介绍：
    快速排序是对冒泡排序的一种改进。
     
    基本思想是：
    通过一趟排序将要排序的数据分割成独立的两部分
    其中一部分的所有数据都比另外一部分的所有数据都要小
    然后再按此方法对这两部分数据分别进行快速排序
    整个排序过程可以递归进行，以此达到整个数据变成有序序列
    
### 归并排序

    2020-05-27
    归并排序介绍：
    归并排序是利用归并的思想实现的排序方法
    该算法采用经典的分治策略
    分治法将问题分成一些小的问题然后递归求解
    而治的阶段则将分的阶段得到的各答案"修补"在一起
    即分而治之
    
    实现文件：sort包下的MergeSort文件
    
### 基数排序

    2020-05-28
    基数排序(桶排序)介绍：
    1、基数排序属于"分配式"排序，又称"桶子法"。顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些桶中，达到排序的目的。
    2、基数排序法是属于稳定性的排序，是高效率的稳定性排序法。
    3、基数排序是桶排序的扩展。
    4、具体实现：将整数按位数切割成为不同的数字，然后按每个位数分别比较。
    
    基数排序的基本思想：
    1、将所有带比较的数值统一为同样的位数长度，位数较短的在前面补零。
    2、然后，从最低位开始，依次进行排序。
    3、这样从低位排序一直到最高位排序完成以后，数列就变成一个有序序列。
    
## 查找算法

    2020-05-29
    查找算法介绍：
    1、顺序(线性)查找
    2、二分查找/折半查找
    3、插值查找
    4、斐波那契查找
    
    顺序(线性)查找——search包下的SeqSearch文件
    
    二分查找/折半查找——search包下的BinarySearch文件
    
    2020-05-30
    插值查找原理介绍：
    1、插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找
    2、将折半查找中的求mid索引的公式，更改为：int mid = low + (high-low) * (findVal - arr[low]) / (arr[high] - arr[low])
    说明：low表示左边索引，high表示右边索引，findVal是要查找的值，上述公式即为插值索引的求取
    
    代码实现文件——search包下的InsertValueSearch文件
    
    2020-06-01
    斐波那契查找(黄金分割点)基本介绍：
    
    黄金分割点是指把一条线段分割为两个部分，使其中一部分与全长之比等于另一部分与这部分之比。
    取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称中外比。
    
    斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618
    
    斐波那契原理：
    斐波那契查找原理与前两种相似，仅仅改变了中间结点(mid)的位置
    mid不再是中间或插值得到，而是位于黄金分割点附近，mid=low + F(k-1) - 1
    
    代码实现文件——sort包下的FibonacciSearch文件
    
## 哈希表  

    2020-06-02
    
    散列表(Hash Table，也叫哈希表)：
    是根据关键码值(key-value)而直接进行访问的数据结构。
    也就是说，它通过关键码值映射到表中一个位置来访问记录，以加快查找的速度。
    这个映射函数叫叫做散列函数，存放记录的数组叫散列表。
    
    代码实现实现文件——hashtab包下的HashTabDemo文件
    
## 树结构基础部分

    2020-06-03
    为什么需要树这种数据结构？
    1、数组存储方式的分析
        优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。
        缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率低。
    2、链式存储方式的分析
        优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。
        缺点：在进行检索时，效率仍然较低，比如检索某个值，需要从头节点开始遍历。
    3、树存储方式的分析
        能提高数据存储，读取的效率。
        比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以数据的插入，删除，修改的速度。
        
    树的常用术语：节点、根节点、父节点、子节点、叶子节点(没有子节点的节点)、节点的权(节点值)、路径(从root节点找到该节点的路线)
                层、子树、树的高度(最大层数)、森林(多颗子树构成森林)
                
    二叉树的概念：
        1、树有很多种，每个节点最多只能有两个节点的一种形式称为二叉树。
        2、二叉树的子节点分为左节点和右节点。
        3、如果该二叉树的所有叶子节点都在最后一层，并且节点总数=2^n-1,n为层数，则我们称为满二叉树。
        4、如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，
            而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，则称之为完全二叉树。
    
    2020-06-04
    二叉树遍历的说明：
        前序遍历：先输出父节点，再遍历左子树和右子树
        中序遍历：先遍历左子树，在输出父节点，再遍历右子树
        后序遍历：先遍历左子树，在遍历右子树，最后输出父节点
        小结：看输出父节点的顺序，就确定是前序，中序还是后序。
        
    分析二叉树的前序、中序、后序的遍历步骤
        1、创建一颗二叉树
        2、前序遍历
            2.1、先输出当前节点(初始的时候是root节点)
            2.2、如果当前节点的左子节点不为空，这递归进行前序遍历
            2.3、如果当前节点的右子节点不为空，则递归进行前序遍历
        3、中序遍历
            3.1、如果当前节点的左子节点不为空，则递归中序遍历
            3.2、输出当前节点
            3.3、如果当前节点的右子节点不为空，着递归中序遍历
        4、后序遍历
            4.1、如果当前节点的左子节点不为空，则递归后序遍历
            4.2、如果当前节点的右子节点不为空，着递归后序遍历
            4.3、输出当前节点
    
    
    
    
    
    
    
 
 
 
 
    
    
    
    
    
    
 